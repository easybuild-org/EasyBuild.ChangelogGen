namespace EasyBuild.ChangelogGen.Commands

open Spectre.Console
open Spectre.Console.Cli
open System.ComponentModel
open System.IO
open LibGit2Sharp

type GenerateSettings() =
    inherit CommandSettings()

    [<CommandArgument(0, "<changelog>")>]
    [<Description("Path to the changelog file. Default is CHANGELOG.md")>]
    member val Changelog: string = "CHANGELOG.md" with get, set

    [<CommandOption("-c|--config")>]
    [<Description("Path to the configuration file")>]
    member val Config: string option = None with get, set

    [<CommandOption("--from")>]
    [<Description("Start commit reference. When not provided, Changelog [bold]last_commit_released[/] metadata will be used, if not found, the [bold]first commit in HEAD[/] will be used.")>]
    member val From: string option = None with get, set

    [<CommandOption("--to")>]
    [<Description("End commit reference. When not provided, the [bold]latest commit in HEAD[/] will be used.")>]
    member val To: string option = None with get, set

    [<CommandOption("--allow-dirty")>]
    [<Description("Allow to run in a dirty repository (having not commit changes in your reporitory)")>]
    member val AllowDirty: bool = false with get, set


    [<CommandOption("--allow-branch <VALUES>")>]
    [<Description("List of branches that are allowed to be used to generate the changelog. Default is 'main'")>]
    member val AllowBranch: string array = [| "main" |] with get, set

    [<CommandOption("--major")>]
    [<Description("Increment major version")>]
    member val Major: bool = false with get, set

    [<CommandOption("--minor")>]
    [<Description("Increment minor version")>]
    member val Minor: bool = false with get, set

    [<CommandOption("--patch")>]
    [<Description("Increment patch version")>]
    member val Patch: bool = false with get, set

    [<CommandOption("--tag <VALUES>")>]
    [<Description("Comma separated list of tags to include in the changelog")>]
    member val Tag: string array = [||] with get, set

    [<CommandOption("--beta [prefix]")>]
    [<Description("Indicate that the generated version is a beta version. Optionally, you can provide a prefix for the beta version. Default is 'beta'")>]
    member val Beta: FlagValue<string> = null with get, set

    [<CommandOption("--cwd")>]
    [<Description("Path to the directory where the command will be executed. Default is the current working directory")>]
    member val Cwd: string = Directory.GetCurrentDirectory() with get, set



// [<RequireQualifiedAccess>]
// type LoadConfig =
//     | Failed
//     | Success of Config.Config

module Prelude =

    [<Literal>]
    let EMPTY_CHANGELOG = """# Changelog

All notable changes to this project will be documented in this file.

This project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

This changelog is generated using [EasyBuild.ChangelogGen](https://github.com/easybuild-org/EasyBuild.ChangelogGen). Do not edit this file manually.

<!-- EasyBuild: START -->
<!-- EasyBuild: END -->
    """

type GenerateCommand() =
    inherit Command<GenerateSettings>()

    // let tryLoadConfig (settings: GenerateSettings) =
    //     match settings.Config with
    //     | Some configFile ->
    //         let configFile =
    //             if Path.IsPathFullyQualified(configFile) then
    //                 configFile
    //             else
    //                 Path.Combine(Directory.GetCurrentDirectory(), configFile) |> Path.GetFullPath

    //         let configFile = FileInfo(configFile)

    //         if not configFile.Exists then
    //             AnsiConsole.MarkupLine(
    //                 $"[red]Error:[/] Configuration file '{configFile.FullName}' does not exist."
    //             )

    //             LoadConfig.Failed
    //         else

    //             let configContent = File.ReadAllText(configFile.FullName)

    //             match Decode.fromString Config.Config.decoder configContent with
    //             | Ok config -> config |> LoadConfig.Success
    //             | Error error ->
    //                 AnsiConsole.MarkupLine(
    //                     $"[red]Error:[/] Failed to parse configuration file:\n\n{error}"
    //                 )

    //                 LoadConfig.Failed

    //     | None -> Config.defaultConfig |> LoadConfig.Success

    interface ICommandLimiter<GenerateSettings>

    override __.Execute(context, settings) =

        // Print settings

        printfn "--allow-dirty: %A" settings.AllowDirty
        printfn "--from: %A" settings.From
        printfn "--to: %A" settings.To
        printfn "<changelog>: %A" settings.Changelog
        printfn "--major: %A" settings.Major
        printfn "--minor: %A" settings.Minor
        printfn "--patch: %A" settings.Patch
        printfn "--tags: %A" settings.Tag
        printfn "--beta: %A" settings.Beta
        printfn "--cwd: %A" settings.Cwd

        use repository = new Repository(settings.Cwd)

        if not (Array.contains repository.Head.FriendlyName settings.AllowBranch) then
            Log.error($"Branch '{repository.Head.FriendlyName}' is not allowed to generate the changelog.")
            1
        else

            if repository.RetrieveStatus().IsDirty && not settings.AllowDirty then
                Log.error "Repository is dirty. Please commit or stash your changes before generating the changelog."
                1
            else


                let changelogFile = FileInfo(Path.Combine(settings.Cwd, settings.Changelog))

                let changelogContent =
                    if not changelogFile.Exists then
                        Log.info($"File '{changelogFile.FullName}' does not exist.")
                        Prelude.EMPTY_CHANGELOG
                    else
                        Log.info($"Changelog file '{changelogFile.FullName}' found.")
                        File.ReadAllText(changelogFile.FullName)

                let changelogLines =
                    changelogContent.Replace("\r\n", "\n").Split('\n')

                printfn "%s" changelogContent

                0

        // Information user about how we are searching for the commit thids should help debug things out
        // Like if the user provided the tag as a comma separated list instead of multiple --tag options

        // let commitFilePath =
        //     if Path.IsPathFullyQualified(settings.CommitFile) then
        //         settings.CommitFile
        //     else
        //         Path.Combine(Directory.GetCurrentDirectory(), settings.CommitFile)
        //         |> Path.GetFullPath

        // let commitFile = FileInfo(commitFilePath)

        // if not commitFile.Exists then
        //     AnsiConsole.MarkupLine($"[red]Error:[/] File '{commitFile.FullName}' does not exist.")
        //     1
        // else

        //     let commitMessage = File.ReadAllText(commitFile.FullName)

        //     match tryLoadConfig settings with
        //     | LoadConfig.Failed -> 1
        //     | LoadConfig.Success config ->
        //         match Parser.validateCommitMessage config commitMessage with
        //         | Ok _ ->
        //             AnsiConsole.MarkupLine("[green]Success:[/] Commit message is valid.")
        //             0
        //         | Error error ->
        //             AnsiConsole.MarkupLine($"[red]Error:[/] {Markup.Escape(error)}")
        //             1


        // printfn "Generate command"
        // 0
