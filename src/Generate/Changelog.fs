module EasyBuild.ChangelogGen.Generate.Changelog

open System
open System.IO
open FsToolkit.ErrorHandling
open Semver
open EasyBuild.ChangelogGen
open EasyBuild.ChangelogGen.Types
open EasyBuild.ChangelogGen.Generate.Types
open System.Text.RegularExpressions

[<Literal>]
let EMPTY_CHANGELOG =
    """# Changelog

All notable changes to this project will be documented in this file.

This project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

This changelog is generated using [EasyBuild.ChangelogGen](https://github.com/easybuild-org/EasyBuild.ChangelogGen). Do not edit this file manually.
"""

let findVersions (content: string) =

    let matches =
        Regex.Matches(
            content,
            "^##\\s\\[?v?(?<version>[\\w\\d.-]+\\.[\\w\\d.-]+[a-zA-Z0-9])\\]?(\\s-\\s(?<date>\\d{4}-\\d{2}-\\d{2}))?$",
            RegexOptions.Multiline
        )

    matches
    |> Seq.map (fun m ->
        let version = m.Groups.["version"].Value

        match SemVersion.TryParse(version, SemVersionStyles.Strict) with
        | true, version -> version
        | false, _ -> failwith "Invalid version"
    )
    |> Seq.toList

let load (settings: GenerateSettings) =
    let changelogFile = FileInfo settings.Changelog

    if not changelogFile.Exists then
        Log.info ($"File '{changelogFile.FullName}' does not exist, creating a new one.")

        {
            File = changelogFile
            Content = EMPTY_CHANGELOG
            Versions = []
        }
        |> Ok

    else
        Log.info ($"Changelog file '{changelogFile.FullName}' found.")

        let changelogContent = File.ReadAllText(changelogFile.FullName)

        {
            File = changelogFile
            Content = changelogContent
            Versions = findVersions changelogContent
        }
        |> Ok

let tryFindAdditionalChangelogContent (text: string) : string list list =
    let lines = text.Replace("\r\n", "\n").Split('\n') |> Seq.toList

    let rec apply
        (acc: string list list)
        (lines: string list)
        (currentBlock: string list)
        (isInsideChangelogBlock: bool)
        =
        match lines with
        | [] -> acc
        | line :: rest ->
            if isInsideChangelogBlock then
                if line = "=== changelog ===" then
                    apply (acc @ [ currentBlock ]) rest [] false
                else
                    apply acc rest (currentBlock @ [ line ]) true
            else if line = "=== changelog ===" then
                apply acc rest currentBlock true
            else
                apply acc rest currentBlock false

    apply [] lines [] false

let private capitalizeFirstLetter (text: string) =
    (string text.[0]).ToUpper() + text.[1..]

module Literals =

    module Type =

        [<Literal>]
        let BREAKING_CHANGE = "breaking change"

        [<Literal>]
        let FEAT = "feat"

        [<Literal>]
        let FIX = "fix"

let (|BreakingChange|Feat|Fix|Other|) (commit: EasyBuild.CommitParser.Types.CommitMessage) =
    if commit.BreakingChange then
        BreakingChange
    elif commit.Type = Literals.Type.FEAT then
        Feat
    elif commit.Type = Literals.Type.FIX then
        Fix
    else
        Other

type GroupedCommits =
    {
        BreakingChanges: CommitForRelease list
        Feats: CommitForRelease list
        Fixes: CommitForRelease list
    }

type Writer() =
    let lines = ResizeArray<string>()

    member _.AppendLine(line: string) = lines.Add(line)

    member _.NewLine() = lines.Add("")

    member _.ToText() = lines |> String.concat "\n"

let private writeSection
    (writer: Writer)
    (label: string)
    (githubRemote: GithubRemoteConfig)
    (commits: CommitForRelease list)
    =
    if commits.Length > 0 then
        writer.AppendLine $"### %s{label}"
        writer.NewLine()

        for commit in commits do
            let githubCommitUrl sha =
                $"https://github.com/%s{githubRemote.Owner}/%s{githubRemote.Repository}/commit/%s{sha}"

            let commitUrl = githubCommitUrl commit.OriginalCommit.Hash

            let description = capitalizeFirstLetter commit.SemanticCommit.Description

            $"* %s{description} ([%s{commit.OriginalCommit.AbbrevHash}](%s{commitUrl}))"
            |> writer.AppendLine

            let additionalChangelogContent =
                tryFindAdditionalChangelogContent commit.SemanticCommit.Body

            for blockLines in additionalChangelogContent do
                writer.NewLine()

                for line in blockLines do
                    $"    %s{line}" |> _.TrimEnd() |> writer.AppendLine

        writer.NewLine()

let generateNewVersionSection (githubRemote: GithubRemoteConfig) (releaseContext: BumpInfo) =
    let writer = Writer()

    writer.AppendLine $"## %s{releaseContext.NewVersion.ToString()}"
    writer.NewLine()

    let rec groupCommits (acc: GroupedCommits) (commits: CommitForRelease list) =

        match commits with
        | [] -> acc
        | commit :: rest ->
            match commit.SemanticCommit with
            | BreakingChange ->
                groupCommits { acc with BreakingChanges = commit :: acc.BreakingChanges } rest
            | Feat -> groupCommits { acc with Feats = commit :: acc.Feats } rest
            | Fix -> groupCommits { acc with Fixes = commit :: acc.Fixes } rest
            // This commit type is not to be emitted in the changelog
            | Other -> groupCommits acc rest

    let groupedCommits =
        groupCommits
            {
                BreakingChanges = []
                Feats = []
                Fixes = []
            }
            releaseContext.CommitsForRelease

    writeSection writer "🏗️ Breaking changes" githubRemote groupedCommits.BreakingChanges
    writeSection writer "🚀 Features" githubRemote groupedCommits.Feats
    writeSection writer "🐞 Bug Fixes" githubRemote groupedCommits.Fixes

    writer.ToText()

let updateWithNewVersion
    (githubRemote: GithubRemoteConfig)
    (releaseContext: BumpInfo)
    (changelogInfo: ChangelogInfo)
    =
    let newVersionLines = generateNewVersionSection githubRemote releaseContext

    let rec removeConsecutiveEmptyLines
        (previousLineWasBlank: bool)
        (result: string list)
        (lines: string list)
        =
        match lines with
        | [] -> result
        | line :: rest ->
            if previousLineWasBlank && String.IsNullOrWhiteSpace(line) then
                removeConsecutiveEmptyLines true result rest
            else
                removeConsecutiveEmptyLines
                    (String.IsNullOrWhiteSpace(line))
                    (result @ [ line ])
                    rest

    let hasEasyBuildMetadata =
        changelogInfo.Lines |> Seq.contains "<!-- EasyBuild: START -->"

    let newChangelogContent =
        [
            // Add title and description of the original changelog
            if hasEasyBuildMetadata then
                yield!
                    changelogInfo.Lines
                    |> Seq.takeWhile (fun line -> "<!-- EasyBuild: START -->" <> line)
            else
                yield!
                    changelogInfo.Lines |> Seq.takeWhile (fun line -> not (line.StartsWith("##")))

            // Ad EasyBuild metadata
            "<!-- EasyBuild: START -->"
            $"<!-- last_commit_released: {releaseContext.LastCommitSha} -->"
            "<!-- EasyBuild: END -->"
            ""

            // New version
            newVersionLines

            // Add the rest of the changelog
            yield! changelogInfo.Lines |> Seq.skipWhile (fun line -> not (line.StartsWith("##")))
        ]
        |> removeConsecutiveEmptyLines false []
        |> String.concat "\n"

    newChangelogContent
