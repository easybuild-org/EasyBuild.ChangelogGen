module EasyBuild.ChangelogGen.Generate.Changelog

open System
open System.IO
open FsToolkit.ErrorHandling
open Semver
open EasyBuild.ChangelogGen
open EasyBuild.ChangelogGen.Types
open EasyBuild.ChangelogGen.Generate.Types

[<Literal>]
let EMPTY_CHANGELOG =
    """# Changelog

All notable changes to this project will be documented in this file.

This project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

This changelog is generated using [EasyBuild.ChangelogGen](https://github.com/easybuild-org/EasyBuild.ChangelogGen). Do not edit this file manually.

<!-- EasyBuild: START -->
<!-- EasyBuild: END -->

## 0.0.0

<!--
This version is here for programs like [EasyBuild.PackageReleaseNotes.Tasks](https://github.com/easybuild-org/EasyBuild.PackageReleaseNotes.Tasks)
to be able to build your project when working on the first version.
-->
"""

let load (settings: GenerateSettings) =
    let changelogFile = FileInfo(Path.Combine(settings.Cwd, settings.Changelog))

    if not changelogFile.Exists then
        Log.info ($"File '{changelogFile.FullName}' does not exist, creating a new one.")

        {
            File = changelogFile
            Content = EMPTY_CHANGELOG
            LastVersion = SemVersion(0, 0, 0)
        }
        |> Ok

    else
        Log.info ($"Changelog file '{changelogFile.FullName}' found.")

        let changelogContent = File.ReadAllText(changelogFile.FullName)

        let lastVersion =
            match LastVersionFinder.tryFindLastVersion changelogContent with
            | Ok version -> Ok version.Version
            | Error LastVersionFinder.NoVersionFound -> Ok(SemVersion(0, 0, 0))
            | Error error -> Error(error.ToText())

        lastVersion
        |> Result.map (fun version ->
            {
                File = changelogFile
                Content = changelogContent
                LastVersion = version
            }
        )

let tryFindAdditionalChangelogContent (text: string) : string list list =
    let lines = text.Replace("\r\n", "\n").Split('\n') |> Seq.toList

    let rec apply
        (acc: string list list)
        (lines: string list)
        (currentBlock: string list)
        (isInsideChangelogBlock: bool)
        =
        match lines with
        | [] -> acc
        | line :: rest ->
            if isInsideChangelogBlock then
                if line = "=== changelog ===" then
                    apply (acc @ [ currentBlock ]) rest [] false
                else
                    apply acc rest (currentBlock @ [ line ]) true
            else if line = "=== changelog ===" then
                apply acc rest currentBlock true
            else
                apply acc rest currentBlock false

    apply [] lines [] false

let private capitalizeFirstLetter (text: string) =
    (string text.[0]).ToUpper() + text.[1..]

let generateNewVersionSection (config: ChangelogGenConfig) (releaseContext: BumpInfo) =
    let newVersionLines = ResizeArray<string>()

    let appendLine (line: string) = newVersionLines.Add(line)

    let newLine () = newVersionLines.Add("")

    appendLine ($"## %s{releaseContext.NewVersion.ToString()}")
    newLine ()

    let groupMap =
        config.Groups |> List.map (fun group -> group.Type, group) |> Map.ofList

    let dedicatedBreakingChangeGroup =
        match Map.tryFind "breaking change" groupMap with
        | None -> false
        | Some _ -> true

    let rec groupCommits
        (acc: Map<string, CommitForRelease list>)
        (commits: CommitForRelease list)
        =

        let addOrUpdate
            (key: string)
            (value: CommitForRelease)
            (map: Map<string, CommitForRelease list>)
            =
            match Map.tryFind key map with
            | None -> map.Add(key, [ value ])
            | Some commits -> map.Add(key, commits @ [ value ])

        match commits with
        | [] -> acc
        | commit :: rest ->
            match Map.tryFind commit.SemanticCommit.Type groupMap with
            // This commit type is not to be emitted in the changelog
            | None -> groupCommits acc rest
            | Some groupInfo ->
                let newAcc =
                    if commit.SemanticCommit.BreakingChange && dedicatedBreakingChangeGroup then
                        addOrUpdate "breaking change" commit acc
                    else
                        addOrUpdate groupInfo.Type commit acc

                groupCommits newAcc rest

    let groupedCommits = groupCommits Map.empty releaseContext.CommitsForRelease

    config.Groups
    |> List.iter (fun groupInfo ->
        match Map.tryFind groupInfo.Type groupedCommits with
        | Some commits ->
            appendLine ($"### %s{groupInfo.Group}")
            newLine ()

            for commit in commits do
                let githubCommitUrl sha =
                    $"https://github.com/%s{config.Github.Owner}/%s{config.Github.Repository}/commit/%s{sha}"

                let commitUrl = githubCommitUrl commit.OriginalCommit.Hash

                let description = capitalizeFirstLetter commit.SemanticCommit.Description

                $"* %s{description} ([%s{commit.OriginalCommit.AbbrevHash}](%s{commitUrl}))"
                |> appendLine

                let additionalChangelogContent =
                    tryFindAdditionalChangelogContent commit.SemanticCommit.Body

                for blockLines in additionalChangelogContent do
                    appendLine ""

                    for line in blockLines do
                        $"    %s{line}" |> _.TrimEnd() |> appendLine

            newLine ()
        | None -> () // Can happen if there are no commits for this group
    )

    newVersionLines |> String.concat "\n"

let updateWithNewVersion
    (config: ChangelogGenConfig)
    (releaseContext: BumpInfo)
    (changelogInfo: ChangelogInfo)
    =
    let newVersionLines = generateNewVersionSection config releaseContext

    let rec removeConsecutiveEmptyLines
        (previousLineWasBlank: bool)
        (result: string list)
        (lines: string list)
        =
        match lines with
        | [] -> result
        | line :: rest ->
            if previousLineWasBlank && String.IsNullOrWhiteSpace(line) then
                removeConsecutiveEmptyLines true result rest
            else
                removeConsecutiveEmptyLines
                    (String.IsNullOrWhiteSpace(line))
                    (result @ [ line ])
                    rest

    let hasEasyBuildMetadata =
        changelogInfo.Lines |> Seq.contains "<!-- EasyBuild: START -->"

    let newChangelogContent =
        [
            // Add title and description of the original changelog
            if hasEasyBuildMetadata then
                yield!
                    changelogInfo.Lines
                    |> Seq.takeWhile (fun line -> "<!-- EasyBuild: START -->" <> line)
            else
                yield!
                    changelogInfo.Lines |> Seq.takeWhile (fun line -> not (line.StartsWith("##")))

            // Ad EasyBuild metadata
            "<!-- EasyBuild: START -->"
            $"<!-- last_commit_released: {releaseContext.LastCommitSha} -->"
            "<!-- EasyBuild: END -->"
            ""

            // New version
            newVersionLines

            // Add the rest of the changelog
            yield! changelogInfo.Lines |> Seq.skipWhile (fun line -> not (line.StartsWith("##")))
        ]
        |> removeConsecutiveEmptyLines false []
        |> String.concat "\n"

    newChangelogContent
